{"version":3,"file":"index.esm.js","sources":["../src/enhancers/helpers/index.ts","../src/enhancers/helpers/logger.ts","../src/constants.ts","../src/enhancers/withPersistTokens/constants.ts","../src/enhancers/withPersistTokens/helpers.ts","../src/enhancers/withFingerprint/constants.ts","../src/enhancers/withFingerprint/helpers.ts","../src/enhancers/withFingerprint/index.ts","../src/enhancers/withLastLoggedInUser/constants.ts","../src/enhancers/withLastLoggedInUser/helpers.ts","../src/enhancers/withLastLoggedInUser/index.ts","../src/enhancers/withNotifications/helpers.ts","../src/enhancers/withNotifications/index.ts","../src/enhancers/withPersistTokens/index.ts","../src/sdk/webauthn.ts","../src/apiPaths.ts","../src/sdk/fedcm.ts","../src/sdk/flow.ts","../src/sdk/index.ts","../src/index.ts","../src/enhancers/helpers/compose.ts","../src/enhancers/withAutoRefresh/index.ts","../src/enhancers/withAutoRefresh/helpers.ts","../src/enhancers/withAnalytics.ts"],"sourcesContent":["import { JWTResponse, UserResponse } from '@descope/core-js-sdk';\nimport { CoreSdkConfig } from '../../types';\n\n/**\n * Add hooks to an existing core-sdk config\n */\nexport const addHooks = <Config extends CoreSdkConfig>(\n  config: Config,\n  hooks: Config['hooks']\n): Config => {\n  ['beforeRequest', 'afterRequest'].reduce((acc, key) => {\n    acc[key] = [].concat(config.hooks?.[key] || []).concat(hooks?.[key] || []);\n\n    return acc;\n  }, (config.hooks ??= {}));\n\n  return config;\n};\n\nexport { compose } from './compose';\n\n/**\n * Extract auth info (JWT response) from fetch response\n * We assume that the auth info is under a \"authInfo\" attribute (flow response)\n * Or the body itself (other auth methods response)\n */\nexport const getAuthInfoFromResponse = async (\n  res: Response\n): Promise<Partial<JWTResponse>> => {\n  if (!res?.ok) return {};\n  const body = await res?.clone().json();\n  return body?.authInfo || body || {};\n};\n\n/**\n * Extract user from fetch response\n * User my exist under \"user\" attribute (auth methods response)\n * Or the body itself (when calling \"me\")\n */\nexport const getUserFromResponse = async (\n  res: Response\n): Promise<UserResponse> | undefined => {\n  const authInfo = await getAuthInfoFromResponse(res);\n\n  return (\n    authInfo?.user ||\n    (authInfo?.hasOwnProperty('userId')\n      ? (authInfo as UserResponse)\n      : undefined)\n  );\n};\n\nexport const isLocalStorage = typeof localStorage !== 'undefined';\n\nexport const setLocalStorage = (key: string, value: string) =>\n  isLocalStorage && localStorage?.setItem(key, value);\nexport const getLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.getItem(key);\nexport const removeLocalStorage = (key: string) =>\n  isLocalStorage && localStorage?.removeItem(key);\n","const logger = {\n  debug: (...args: any[]) => {\n    // eslint-disable-next-line no-console\n    console.debug(...args);\n  },\n};\n\nexport default logger;\n","// This sdk can be used in SSR apps\nexport const IS_BROWSER = typeof window !== 'undefined';\n\n// Maximum timeout value for setTimeout\n// For more information, refer to https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#maximum_delay_value\nexport const MAX_TIMEOUT = Math.pow(2, 31) - 1;\n","/** Default name for the session cookie name / local storage key */\nexport const SESSION_TOKEN_KEY = 'DS';\n/** Default name for the refresh local storage key */\nexport const REFRESH_TOKEN_KEY = 'DSR';\n","import { JWTResponse } from '@descope/core-js-sdk';\nimport Cookies from 'js-cookie';\nimport { BeforeRequestHook } from '../../types';\nimport { REFRESH_TOKEN_KEY, SESSION_TOKEN_KEY } from './constants';\nimport {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\n\n/**\n * Store the session JWT as a cookie on the given domain and path with the given expiration.\n * This is useful so that the application backend will automatically get the cookie for the session\n * @param name cookie name\n * @param value The JWT to store as a cookie\n * @param cookieParams configuration that is usually returned from the JWT\n */\nfunction setJwtTokenCookie(\n  name: string,\n  value: string,\n  { cookiePath, cookieDomain, cookieExpiration }: Partial<JWTResponse>,\n) {\n  if (value) {\n    const expires = new Date(cookieExpiration * 1000); // we are getting response from the server in seconds instead of ms\n    // Since its a JS cookie, we don't set the domain because we want the cookie to be on the same domain as the application\n    const domainMatches = isCurrentDomainOrParentDomain(cookieDomain);\n    Cookies.set(name, value, {\n      path: cookiePath,\n      domain: domainMatches ? cookieDomain : undefined,\n      expires,\n      sameSite: 'Strict',\n      secure: true,\n    });\n  }\n}\n\n/*\n * Check if the cookie domain is the same as the current domain or the parent domain\n * Examples:\n * 1. cookie domain: 'example.com', current domain: 'example.com' => true\n * 2. cookie domain: 'example.com', current domain: 'sub.example.com' => true\n * 3. cookie domain: 'example.com', current domain: 'sub.sub.example.com' => true\n * 4. cookie domain: 'example.com', current domain: 'another.com' => false\n * 5. cookie domain: 'example.com', current domain: 'example.co.il' => false\n */\nfunction isCurrentDomainOrParentDomain(cookieDomain: string): boolean {\n  const currentDomain = window.location.hostname;\n  const currentDomainParts = currentDomain.split('.');\n  const cookieDomainParts = cookieDomain.split('.');\n\n  // check if the cookie domain items are the last items in the current domain\n  const currentDomainSuffix = currentDomainParts\n    .slice(-cookieDomainParts.length)\n    .join('.');\n  return currentDomainSuffix === cookieDomain;\n}\n\nexport const persistTokens = (\n  { refreshJwt, sessionJwt, ...cookieParams } = {} as Partial<JWTResponse>,\n  sessionTokenViaCookie = false,\n  storagePrefix = '',\n) => {\n  // persist refresh token\n  refreshJwt &&\n    setLocalStorage(`${storagePrefix}${REFRESH_TOKEN_KEY}`, refreshJwt);\n\n  // persist session token\n  if (sessionJwt) {\n    sessionTokenViaCookie\n      ? setJwtTokenCookie(SESSION_TOKEN_KEY, sessionJwt, cookieParams)\n      : setLocalStorage(`${storagePrefix}${SESSION_TOKEN_KEY}`, sessionJwt);\n  }\n};\n\n/** Return the refresh token from the localStorage. Not for production usage because refresh token will not be saved in localStorage. */\nexport function getRefreshToken(prefix: string = '') {\n  return getLocalStorage(`${prefix}${REFRESH_TOKEN_KEY}`) || '';\n}\n\n/**\n * Return the session token. first try to get from cookie, and fallback to local storage\n * See sessionTokenViaCookie option for more details about session token location\n */\nexport function getSessionToken(prefix: string = ''): string {\n  return (\n    Cookies.get(SESSION_TOKEN_KEY) ||\n    getLocalStorage(`${prefix}${SESSION_TOKEN_KEY}`) ||\n    ''\n  );\n}\n\n/** Remove both the localStorage refresh JWT and the session cookie */\nexport function clearTokens(prefix: string = '') {\n  removeLocalStorage(`${prefix}${REFRESH_TOKEN_KEY}`);\n  removeLocalStorage(`${prefix}${SESSION_TOKEN_KEY}`);\n  Cookies.remove(SESSION_TOKEN_KEY);\n}\n\nexport const beforeRequest =\n  (prefix?: string): BeforeRequestHook =>\n  (config) =>\n    Object.assign(config, { token: config.token || getRefreshToken(prefix) });\n","import { IS_BROWSER } from '../../constants';\n\nconst FINGERPRINT_PUBLIC_KEY = 'fingerprint.public.key';\nconst FINGERPRINT_ENDPOINT_URL = 'fingerprint.endpoint.url';\n\n/** Fingerprint.js cloudflare integration */\nexport const FP_EP_URL =\n  (IS_BROWSER && localStorage?.getItem(FINGERPRINT_ENDPOINT_URL)) ||\n  'https://api.descope.com';\nexport const FP_CF_ENDPOINT_PATH = '/fXj8gt3x8VulJBna/x96Emn69oZwcd7I6';\nexport const FP_CF_SCRIPT_PATH = '/fXj8gt3x8VulJBna/w78aRZnnDZ3Aqw0I';\n/** Fingerprint visitor data */\nexport const FP_BODY_DATA = 'fpData';\n/** Session ID for visitor */\nexport const VISITOR_SESSION_ID_PARAM = 'vsid';\n/** Request ID for visitor */\nexport const VISITOR_REQUEST_ID_PARAM = 'vrid';\n/** FP storage key */\nexport const FP_STORAGE_KEY = 'fp';\n// Storage FP Keys TTL is 24 hours\nexport const STORAGE_TTL_MS = 24 * 60 * 60 * 1000;\n","import {\n  load,\n  defaultEndpoint,\n  defaultScriptUrlPattern,\n} from '@fingerprintjs/fingerprintjs-pro';\nimport {\n  FP_EP_URL,\n  FP_CF_ENDPOINT_PATH,\n  FP_CF_SCRIPT_PATH,\n  FP_STORAGE_KEY,\n  STORAGE_TTL_MS,\n  VISITOR_REQUEST_ID_PARAM,\n  VISITOR_SESSION_ID_PARAM,\n} from './constants';\nimport { FingerprintObject } from './types';\n\nconst createFingerprintObject = (\n  sessionId: string,\n  requestId: string,\n): FingerprintObject => ({\n  [VISITOR_SESSION_ID_PARAM]: sessionId,\n  [VISITOR_REQUEST_ID_PARAM]: requestId,\n});\n\n/** Generate UUID based on current time and some randomness */\nconst generateUUID = () => {\n  // return alphanumeric, sortable uuid of 27 characters\n  return (\n    Date.now().toString(36) +\n    Math.random().toString(36).substring(2) + // removing '0.' prefix\n    Math.random().toString(36).substring(2)\n  ).substring(0, 27);\n};\n\n// Set FP data to storage with expiration\n// We set the request id and session id together so they will have the same TTL\n// This implementation is based on https://www.sohamkamani.com/javascript/localstorage-with-ttl-expiry/\nconst setFPToStorage = (value: FingerprintObject) => {\n  const now = new Date();\n  // `item` is an object which contains the value\n  // as well as the time when it's supposed to expire\n  const item = {\n    value,\n    expiry: now.getTime() + STORAGE_TTL_MS,\n  };\n  localStorage.setItem(FP_STORAGE_KEY, JSON.stringify(item));\n};\n\n// Get Fingerprint from storage, will return null if not exists, or if expired\nconst getFPFromStorage = (returnExpired = false): FingerprintObject => {\n  const itemStr = localStorage.getItem(FP_STORAGE_KEY);\n  // if the item doesn't exist, return null\n  if (!itemStr) {\n    return null;\n  }\n  const item = JSON.parse(itemStr);\n  const now = new Date();\n  // compare the expiry time of the item with the current time\n  // return null if needed\n  if (now.getTime() > item.expiry && !returnExpired) {\n    return null;\n  }\n  return item.value;\n};\n\n/**\n * Ensure fingerprint ids (request id, session id) exist.\n * If not, It will generate and load them into to browser storage.\n * NOTE: Using fingerprintJS data has cost, use considerably.\n * @param fpKey FingerprintJS API key\n */\nexport const ensureFingerprintIds = async (\n  fpKey: string,\n  baseUrl = FP_EP_URL,\n) => {\n  try {\n    if (getFPFromStorage()) {\n      // FP is already in storage, no need to\n      return;\n    }\n\n    const sessionId = generateUUID();\n\n    const endpointUrl = new URL(baseUrl);\n    endpointUrl.pathname = FP_CF_ENDPOINT_PATH;\n\n    const patterUrl = new URL(baseUrl);\n    patterUrl.pathname = FP_CF_SCRIPT_PATH;\n    const scriptUrlPattern =\n      patterUrl.toString() +\n      '?apiKey=<apiKey>&version=<version>&loaderVersion=<loaderVersion>';\n\n    // load from FingerprintJS\n    const agentP = load({\n      apiKey: fpKey,\n      endpoint: [\n        endpointUrl.toString(),\n        defaultEndpoint, // Fallback to default endpoint in case of error\n      ],\n      scriptUrlPattern: [\n        scriptUrlPattern,\n        defaultScriptUrlPattern, // Fallback to default CDN in case of error\n      ],\n    });\n\n    const agent = await agentP;\n    const { requestId } = await agent.get({ linkedId: sessionId });\n    const fpData = createFingerprintObject(sessionId, requestId);\n    setFPToStorage(fpData);\n  } catch (ex) {\n    // eslint-disable-next-line no-console\n    console.warn('Could not load fingerprint', ex);\n  }\n};\n\n/**\n * Get Fingerprint data (request ids) from storage, or create empty object\n * If data is expired, return it anyway\n */\nexport const getFingerprintData = (): FingerprintObject | null => {\n  // get from storage if exists\n  return getFPFromStorage(true);\n};\n\n/** Clear Fingerprint data from storage */\nexport const clearFingerprintData = () => {\n  localStorage.removeItem(FP_STORAGE_KEY);\n};\n","import { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { BeforeRequestHook } from '../../types';\nimport { addHooks } from '../helpers';\nimport { FP_BODY_DATA } from './constants';\nimport { ensureFingerprintIds, getFingerprintData } from './helpers';\nimport { FingerprintOptions } from './types';\n\nconst beforeRequest: BeforeRequestHook = (config) => {\n  const data = getFingerprintData();\n  if (data && config.body) {\n    config.body[FP_BODY_DATA] = data;\n  }\n\n  return config;\n};\n\n/**\n * Add fingerprint data to outgoing requests\n */\nexport const withFingerprint =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ fpKey, fpLoad, ...config }: Parameters<T>[0] & FingerprintOptions) => {\n    if (!IS_BROWSER) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Fingerprint is a client side only capability and will not work when running in the server',\n      );\n      return createSdk(config);\n    }\n\n    // load fingerprint now if needed\n    if (fpKey && fpLoad) {\n      ensureFingerprintIds(fpKey).catch(\n        // istanbul ignore next\n        () => null,\n      );\n    }\n\n    // Hook added always because fingerprint can be dynamic using flows\n    return createSdk(addHooks(config, { beforeRequest }));\n  };\n","/** Login Id of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_LOGIN_ID = 'dls_last_user_login_id';\n\n/** Display name of the last user logged in */\nexport const LOCAL_STORAGE_LAST_USER_DISPLAY_NAME =\n  'dls_last_user_display_name';\n","import {\n  getLocalStorage,\n  removeLocalStorage,\n  setLocalStorage,\n} from '../helpers';\nimport {\n  LOCAL_STORAGE_LAST_USER_LOGIN_ID,\n  LOCAL_STORAGE_LAST_USER_DISPLAY_NAME,\n} from './constants';\n\nexport const setLastUserLoginId = (loginId: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID, loginId);\n};\n\nexport const getLastUserLoginId = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const removeLastUserLoginId = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_LOGIN_ID);\n};\n\nexport const setLastUserDisplayName = (displayName: string) => {\n  return setLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME, displayName);\n};\n\nexport const getLastUserDisplayName = () => {\n  return getLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n\nexport const removeLastUserDisplayName = () => {\n  return removeLocalStorage(LOCAL_STORAGE_LAST_USER_DISPLAY_NAME);\n};\n","import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook, CoreSdk } from '../../types';\nimport { addHooks, getUserFromResponse } from '../helpers';\nimport {\n  getLastUserLoginId,\n  removeLastUserLoginId,\n  setLastUserLoginId,\n  getLastUserDisplayName,\n  removeLastUserDisplayName,\n  setLastUserDisplayName,\n} from './helpers';\n\n/**\n * Adds last logged in user to flow start request\n */\n// eslint-disable-next-line import/exports-last\nexport const withLastLoggedInUser =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({\n    storeLastAuthenticatedUser = true,\n    ...config\n  }: Parameters<T>[0] & {\n    storeLastAuthenticatedUser?: boolean;\n  }): ReturnType<T> & {\n    getLastUserLoginId: typeof getLastUserLoginId;\n    getLastUserDisplayName: typeof getLastUserDisplayName;\n  } => {\n    if (!storeLastAuthenticatedUser) {\n      // We assign getLastUserLoginId and getLastUserDisplayName to the sdk\n      // To keep the return type consistent\n      return Object.assign(createSdk(config), {\n        getLastUserLoginId,\n        getLastUserDisplayName,\n      }) as any;\n    }\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const userDetails = await getUserFromResponse(res);\n      const loginId = userDetails?.loginIds?.[0];\n      const displayName = userDetails?.name;\n      if (loginId) {\n        setLastUserLoginId(loginId);\n        setLastUserDisplayName(displayName);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    let wrappedSdk = wrapWith(sdk, ['flow.start'], startWrapper);\n    wrappedSdk = wrapWith(wrappedSdk, ['logout', 'logoutAll'], logoutWrapper);\n    return Object.assign(wrappedSdk, {\n      getLastUserLoginId,\n      getLastUserDisplayName,\n    }) as any;\n  };\n\nconst startWrapper: SdkFnWrapper<{}> =\n  (fn) =>\n  async (...args) => {\n    args[1] = args[1] || {};\n    const [, options = {}] = args as unknown as Parameters<\n      CoreSdk['flow']['start']\n    >;\n    const loginId = getLastUserLoginId();\n    const displayName = getLastUserDisplayName();\n\n    if (loginId) {\n      options.lastAuth ??= {};\n      options.lastAuth.loginId = loginId;\n      options.lastAuth.name = displayName;\n    }\n\n    const resp = await fn(...args);\n\n    return resp;\n  };\n\nconst logoutWrapper: SdkFnWrapper<{}> =\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    removeLastUserLoginId();\n    removeLastUserDisplayName();\n\n    return resp;\n  };\n","// create publisher/subscriber instances\nexport function createPubSub<T extends any>() {\n  const cbs = [];\n\n  const sub = (cb: (data: T) => void) => {\n    const idx = cbs.push(cb) - 1;\n    return () => cbs.splice(idx, 1);\n  };\n\n  const pub = (data: T) => {\n    cbs.forEach((cb) => cb(data));\n  };\n\n  return { pub, sub };\n}\n","import { SdkFnWrapper, UserResponse, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk, WebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport {\n  addHooks,\n  getAuthInfoFromResponse,\n  getUserFromResponse,\n} from '../helpers';\nimport { createPubSub } from './helpers';\n\n/**\n * Adds 2 event functions to the sdk,\n * onSessionTokenChange: Gets a callback and call it whenever there is a change in session token\n * onUserChange: Gets a callback and call it whenever there is a change in current logged in user\n */\nexport const withNotifications =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) => {\n    const sessionPS = createPubSub<string | null>();\n    const userPS = createPubSub<UserResponse | null>();\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      if (res?.status === 401) {\n        sessionPS.pub(null);\n        userPS.pub(null);\n      } else {\n        const userDetails = await getUserFromResponse(res);\n        if (userDetails) userPS.pub(userDetails);\n\n        const { sessionJwt } = await getAuthInfoFromResponse(res);\n        if (sessionJwt) sessionPS.pub(sessionJwt);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n\n        sessionPS.pub(null);\n        userPS.pub(null);\n\n        return resp;\n      };\n\n    const wrappedSdk = wrapWith(sdk, ['logout', 'logoutAll'], wrapper);\n\n    return Object.assign(wrappedSdk, {\n      onSessionTokenChange: sessionPS.sub,\n      onUserChange: userPS.sub,\n    });\n  };\n","/* eslint-disable import/exports-last */\nimport { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../../constants';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse } from '../helpers';\nimport {\n  beforeRequest,\n  clearTokens,\n  getRefreshToken,\n  getSessionToken,\n  persistTokens,\n} from './helpers';\nimport { PersistTokensOptions } from './types';\n\n/**\n * Persist authentication tokens in cookie/storage\n */\nexport const withPersistTokens =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  <A extends boolean>({\n    persistTokens: isPersistTokens,\n    sessionTokenViaCookie,\n    storagePrefix,\n    ...config\n  }: Parameters<T>[0] & PersistTokensOptions<A>): A extends true\n    ? ReturnType<T> & {\n        getRefreshToken: () => string;\n        getSessionToken: () => string;\n      }\n    : ReturnType<T> => {\n    if (!isPersistTokens || !IS_BROWSER) {\n      if (isPersistTokens) {\n        // eslint-disable-next-line no-console\n        console.warn(\n          'Storing auth tokens in local storage and cookies are a client side only capabilities and will not be done when running in the server',\n        );\n      }\n      return createSdk(config) as any;\n    }\n\n    const afterRequest: AfterRequestHook = async (req, res) => {\n      const isManagementApi = /^\\/v\\d+\\/mgmt\\//.test(req.path);\n\n      if (res?.status === 401) {\n        if (!isManagementApi) {\n          clearTokens(storagePrefix);\n        }\n      } else {\n        persistTokens(\n          await getAuthInfoFromResponse(res),\n          sessionTokenViaCookie,\n          storagePrefix,\n        );\n      }\n    };\n\n    const sdk = createSdk(\n      addHooks(config, {\n        beforeRequest: beforeRequest(storagePrefix),\n        afterRequest,\n      }),\n    );\n\n    const wrappedSdk = wrapWith(\n      sdk,\n      ['logout', 'logoutAll'],\n      wrapper(storagePrefix),\n    );\n\n    const refreshToken = () => getRefreshToken(storagePrefix);\n    const sessionToken = () => getSessionToken(storagePrefix);\n\n    return Object.assign(wrappedSdk, {\n      getRefreshToken: refreshToken,\n      getSessionToken: sessionToken,\n    }) as any;\n  };\n\nconst wrapper =\n  (prefix?: string): SdkFnWrapper<{}> =>\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    clearTokens(prefix);\n\n    return resp;\n  };\n\nexport default withPersistTokens;\n","import { JWTResponse, SdkResponse, ResponseData } from '@descope/core-js-sdk';\nimport { IS_BROWSER } from '../constants';\nimport { CoreSdk } from '../types';\n\ntype CreateWebauthn = typeof createWebAuthn;\n\nconst withCoreFns =\n  <I extends Parameters<CreateWebauthn>, O extends ReturnType<CreateWebauthn>>(\n    creator: (...args: I) => O\n  ) =>\n  (...args: I) => {\n    const obj = creator(...args);\n\n    Object.assign(obj.signUp, args[0].webauthn.signUp);\n    Object.assign(obj.signIn, args[0].webauthn.signIn);\n    Object.assign(obj.signUpOrIn, args[0].webauthn.signUpOrIn);\n    Object.assign(obj.update, args[0].webauthn.update);\n\n    return obj as {\n      [K in keyof O]: K extends keyof I[0]['webauthn']\n        ? O[K] & I[0]['webauthn'][K]\n        : O[K];\n    };\n  };\n\n/** Constructs a higher level WebAuthn API that wraps the functions from code-js-sdk */\nconst createWebAuthn = (sdk: CoreSdk) => ({\n  async signUp(identifier: string, name: string) {\n    const startResponse = await sdk.webauthn.signUp.start(\n      identifier,\n      window.location.origin,\n      name\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signUp.finish(\n      startResponse.data.transactionId,\n      createResponse\n    );\n    return finishResponse;\n  },\n\n  async signIn(identifier: string) {\n    const startResponse = await sdk.webauthn.signIn.start(\n      identifier,\n      window.location.origin\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    const getResponse = await get(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.signIn.finish(\n      startResponse.data.transactionId,\n      getResponse\n    );\n    return finishResponse;\n  },\n\n  async signUpOrIn(identifier: string) {\n    const startResponse = await sdk.webauthn.signUpOrIn.start(\n      identifier,\n      window.location.origin\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n    if (startResponse.data?.create) {\n      const createResponse = await create(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signUp.finish(\n        startResponse.data.transactionId,\n        createResponse\n      );\n      return finishResponse;\n    } else {\n      const getResponse = await get(startResponse.data.options);\n      const finishResponse = await sdk.webauthn.signIn.finish(\n        startResponse.data.transactionId,\n        getResponse\n      );\n      return finishResponse;\n    }\n  },\n\n  async update(identifier: string, token: string) {\n    const startResponse = await sdk.webauthn.update.start(\n      identifier,\n      window.location.origin,\n      token\n    );\n    if (!startResponse.ok) {\n      return startResponse as SdkResponse<ResponseData>;\n    }\n    const createResponse = await create(startResponse.data.options);\n    const finishResponse = await sdk.webauthn.update.finish(\n      startResponse.data.transactionId,\n      createResponse\n    );\n    return finishResponse;\n  },\n\n  /** Helper functions for working with WebAuthn browser APIs using JSON data */\n  helpers: {\n    /** Wraps the navigation.credentials.create call to translate JSON inputs and outputs */\n    create,\n    /** Wraps the navigation.credentials.get call to translate JSON inputs and outputs */\n    get,\n    /** Checks if the browser supports WebAuthn, and can optionally require in\n     * addition that the browser supports WebAuthn with built-in biometrics */\n    isSupported,\n    conditional,\n  },\n});\n\n// Helpers functions\n\nasync function create(options: string): Promise<string> {\n  const createOptions = decodeCreateOptions(options);\n  const createResponse = (await navigator.credentials.create(\n    createOptions\n  )) as AttestationPublicKeyCredential;\n  return encodeCreateResponse(createResponse);\n}\n\nasync function get(options: string): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  const getResponse = (await navigator.credentials.get(\n    getOptions\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n/**\n * This function should be used in passkeys autofill (conditional UI)\n * It handles the call to \"navigator.credentials.get\" and adds the required options\n * @param options webauthn start options\n * @param abort: AbortController instance\n * @returns encoded \"navigator.credentials.get\" response\n */\nasync function conditional(\n  options: string,\n  abort: AbortController\n): Promise<string> {\n  const getOptions = decodeGetOptions(options);\n  getOptions.signal = abort.signal;\n  getOptions.mediation = 'conditional' as any;\n  const getResponse = (await navigator.credentials.get(\n    getOptions\n  )) as AssertionPublicKeyCredential;\n  return encodeGetResponse(getResponse);\n}\n\n// eslint-disable-next-line import/exports-last\nexport async function isSupported(\n  requirePlatformAuthenticator: boolean = false\n): Promise<boolean> {\n  if (!IS_BROWSER) {\n    return Promise.resolve(false);\n  }\n  const supported = !!(\n    window.PublicKeyCredential &&\n    navigator.credentials &&\n    navigator.credentials.create &&\n    navigator.credentials.get\n  );\n  if (\n    supported &&\n    requirePlatformAuthenticator &&\n    PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable\n  ) {\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n  }\n  return supported;\n}\n\n// Conversion of data structures for Create/Attestation/Register ceremony\n\ntype AttestationPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAttestationResponse;\n};\n\nfunction decodeCreateOptions(value: string): CredentialCreationOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.user.id = decodeBase64Url(options.publicKey.user.id);\n  options.publicKey.excludeCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeCreateResponse(\n  credential: AttestationPublicKeyCredential\n): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      attestationObject: encodeBase64Url(credential.response.attestationObject),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n    },\n  });\n}\n\n// Conversion of data structures for Get/Assertion/Login ceremony\n\ntype AssertionPublicKeyCredential = PublicKeyCredential & {\n  response: AuthenticatorAssertionResponse;\n};\n\nfunction decodeGetOptions(value: string): CredentialRequestOptions {\n  const options = JSON.parse(value);\n  options.publicKey.challenge = decodeBase64Url(options.publicKey.challenge);\n  options.publicKey.allowCredentials?.forEach((item: any) => {\n    item.id = decodeBase64Url(item.id);\n  });\n  return options;\n}\n\nfunction encodeGetResponse(credential: AssertionPublicKeyCredential): string {\n  return JSON.stringify({\n    id: credential.id,\n    rawId: encodeBase64Url(credential.rawId),\n    type: credential.type,\n    response: {\n      authenticatorData: encodeBase64Url(credential.response.authenticatorData),\n      clientDataJSON: encodeBase64Url(credential.response.clientDataJSON),\n      signature: encodeBase64Url(credential.response.signature),\n      userHandle: credential.response.userHandle\n        ? encodeBase64Url(credential.response.userHandle)\n        : undefined,\n    },\n  });\n}\n\n// Conversion between ArrayBuffers and Base64Url strings\n\nfunction decodeBase64Url(value: string): ArrayBufferLike {\n  const base64 = value.replace(/_/g, '/').replace(/-/g, '+');\n  return Uint8Array.from(atob(base64), (c) => c.charCodeAt(0)).buffer;\n}\n\nfunction encodeBase64Url(value: ArrayBufferLike): string {\n  const base64 = btoa(String.fromCharCode.apply(null, new Uint8Array(value)));\n  return base64.replace(/\\//g, '_').replace(/\\+/g, '-').replace(/=/g, '');\n}\n\n// Exports\nexport default withCoreFns(createWebAuthn);\n","export const apiPaths = {\n  fedcm: {\n    config: '/fedcm/config',\n  },\n};\n","import { JWTResponse, SdkResponse, LoginOptions } from '@descope/core-js-sdk';\nimport { CoreSdk } from '../types';\nimport { IS_BROWSER } from '../constants';\nimport { apiPaths } from '../apiPaths';\n\n/**\n * Configuration for OneTap.\n */\ninterface OneTapConfig {\n  /** Whether to auto select. Optional. */\n  auto_select?: boolean;\n\n  /** Whether to cancel on tap outside. Optional. */\n  cancel_on_tap_outside?: boolean;\n\n  /** ID of the prompt parent. Optional. */\n  prompt_parent_id?: string;\n\n  /** Context. Optional. */\n  context?: 'signin' | 'signup' | 'use';\n\n  /** Callback function to handle the intermediate iframe close event. Optional. */\n  intermediate_iframe_close_callback?: () => void;\n\n  /** Whether to support ITP. Optional. */\n  itp_support?: boolean;\n\n  /** Login hint. Optional. */\n  login_hint?: string;\n\n  /** HD. Optional. */\n  hd?: string;\n\n  /** Whether to use FedCM for prompt. Optional. */\n  use_fedcm_for_prompt?: boolean;\n}\n\n/**\n * Response from the credential.\n */\ninterface CredentialResponse {\n  /** Credential. */\n  credential: string;\n\n  /** How the selection was made. */\n  select_by:\n    | 'auto'\n    | 'user'\n    | 'user_1tap'\n    | 'user_2tap'\n    | 'btn'\n    | 'btn_confirm'\n    | 'btn_add_session'\n    | 'btn_confirm_add_session';\n}\n\ninterface FedCMAssertionResponse {\n  token: string;\n  error: {\n    code: string;\n    url: string;\n  };\n}\n\ninterface IdentityProviderConfig {\n  configURL: string;\n  clientId: string;\n}\n\ntype IdentityCredentialRequestOptionsContext =\n  | 'signin'\n  | 'signup'\n  | 'use'\n  | 'continue';\n\ninterface IdentityProviderRequestOptions extends IdentityProviderConfig {\n  nonce?: string;\n  loginHint?: string;\n  domainHint?: string;\n}\n\ninterface IdentityCredentialRequestOptions {\n  providers: IdentityProviderRequestOptions[];\n  context?: IdentityCredentialRequestOptionsContext;\n}\n\ninterface FedCMCredentialRequestOptions {\n  identity?: IdentityCredentialRequestOptions;\n}\n\ntype OneTapInitialize = ({\n  client_id,\n  callback,\n  nonce,\n}: {\n  client_id: string;\n  callback: (res: CredentialResponse) => void;\n  nonce: string;\n} & OneTapConfig) => void;\n\ntype PromptNotification = {\n  isSkippedMoment: () => boolean;\n};\n\n/**\n * Constructs a higher level FedCM API that wraps the functions from code-js-sdk.\n * @param sdk The CoreSdk instance.\n * @returns The FedCM API.\n */\nconst createFedCM = (sdk: CoreSdk, projectId: string) => ({\n  async oneTap(\n    provider?: string,\n    oneTapConfig?: OneTapConfig,\n    loginOptions?: LoginOptions,\n    onSkip?: () => void,\n  ) {\n    const readyProvider = provider ?? 'google';\n    const startResponse = await sdk.oauth.startNative(\n      readyProvider,\n      loginOptions,\n      true,\n    );\n    if (!startResponse.ok) {\n      return startResponse as unknown as SdkResponse<JWTResponse>;\n    }\n\n    const { clientId, stateId, nonce } = startResponse.data;\n    const googleClient = await getGoogleClient();\n    return new Promise((resolve) => {\n      const callback = (res: CredentialResponse) => {\n        resolve(\n          sdk.oauth.finishNative(\n            readyProvider,\n            stateId,\n            '',\n            '',\n            res.credential,\n          ),\n        );\n      };\n\n      // initialize google client\n      googleClient.initialize({\n        ...oneTapConfig,\n        itp_support: oneTapConfig?.itp_support ?? true,\n        use_fedcm_for_prompt: oneTapConfig?.use_fedcm_for_prompt ?? true,\n        client_id: clientId,\n        callback,\n        nonce,\n      });\n\n      googleClient.prompt((notification) => {\n        if (notification?.isSkippedMoment()) {\n          onSkip?.();\n        }\n      });\n    });\n  },\n  async launch(\n    context?: IdentityCredentialRequestOptionsContext,\n  ): Promise<SdkResponse<JWTResponse>> {\n    const configURL = sdk.httpClient.buildUrl(\n      projectId + apiPaths.fedcm.config,\n    );\n    const req: FedCMCredentialRequestOptions = {\n      identity: {\n        context: context || 'signin',\n        providers: [\n          {\n            configURL,\n            clientId: projectId,\n          },\n        ],\n      },\n    };\n    const res = await navigator.credentials?.get(req as any);\n    return sdk.refresh((res as any as FedCMAssertionResponse).token);\n  },\n  isSupported(): boolean {\n    return IS_BROWSER && 'IdentityCredential' in window;\n  },\n});\n\n// Helpers functions\nasync function getGoogleClient(): Promise<{\n  initialize: OneTapInitialize;\n  prompt: (cb: (notification: PromptNotification) => void) => void;\n}> {\n  return new Promise((resolve, reject) => {\n    if ((window as any).google) {\n      resolve((window as any).google.accounts.id);\n      return;\n    }\n\n    /* istanbul ignore next */\n    let googleScript = document.getElementById(\n      'google-gsi-client-script',\n    ) as HTMLScriptElement;\n\n    /* istanbul ignore next */\n    if (!googleScript) {\n      googleScript = document.createElement('script');\n      document.head.appendChild(googleScript);\n      googleScript.async = true;\n      googleScript.defer = true;\n      googleScript.id = 'google-gsi-client-script';\n      googleScript.src = 'https://accounts.google.com/gsi/client';\n    }\n\n    /* istanbul ignore next */\n    googleScript.onload = function () {\n      if ((window as any).google) {\n        resolve((window as any).google.accounts.id);\n      } else {\n        reject('Failed to load Google GSI client script - not loaded properly');\n      }\n    };\n    /* istanbul ignore next */\n    googleScript.onerror = function () {\n      reject('Failed to load Google GSI client script - failed to load');\n    };\n  });\n}\n\nexport default createFedCM;\nexport type { OneTapConfig };\n","import { CoreSdk, ReplaceParam } from '../types';\nimport { isSupported } from './webauthn';\n\ntype CoreSdkFlowStartArgs = Parameters<CoreSdk['flow']['start']>;\ntype Options = Pick<\n  CoreSdkFlowStartArgs[1],\n  | 'tenant'\n  | 'redirectUrl'\n  | 'redirectAuth'\n  | 'oidcIdpStateId'\n  | 'samlIdpStateId'\n  | 'samlIdpUsername'\n  | 'ssoAppId'\n  | 'oidcLoginHint'\n  | 'preview'\n  | 'abTestingKey'\n  | 'client'\n  | 'locale'\n> & {\n  lastAuth?: Omit<CoreSdkFlowStartArgs[1]['lastAuth'], 'loginId' | 'name'>;\n};\n\nconst START_OPTIONS_VERSION_PREFER_START_REDIRECT_URL = 1;\n\nexport default (coreSdk: CoreSdk) => ({\n  ...coreSdk.flow,\n  // wrap start fn and adds more data to the start options\n  start: async (...args: ReplaceParam<CoreSdkFlowStartArgs, '1', Options>) => {\n    const webAuthnSupport = await isSupported();\n    const decoratedOptions = {\n      location: window.location.href,\n      ...args[1],\n      deviceInfo: {\n        webAuthnSupport,\n      },\n      startOptionsVersion: START_OPTIONS_VERSION_PREFER_START_REDIRECT_URL,\n    };\n\n    args[1] = decoratedOptions;\n\n    return coreSdk.flow.start(...args);\n  },\n});\n","import createCoreSdk from '@descope/core-js-sdk';\nimport createWebAuthn from './webauthn';\nimport createFedCM from './fedcm';\nimport withFlow from './flow';\n\nconst createSdk = (...args: Parameters<typeof createCoreSdk>) => {\n  const coreSdk = createCoreSdk(...args);\n\n  return {\n    ...coreSdk,\n    flow: withFlow(coreSdk),\n    webauthn: createWebAuthn(coreSdk),\n    fedcm: createFedCM(coreSdk, args[0].projectId),\n  };\n};\n\nexport default createSdk;\n\nexport type CreateWebSdk = typeof createSdk;\nexport type WebSdk = ReturnType<CreateWebSdk>;\n","import { compose } from './enhancers/helpers';\nimport { withAnalytics } from './enhancers/withAnalytics';\nimport { withAutoRefresh } from './enhancers/withAutoRefresh';\nimport { withFingerprint } from './enhancers/withFingerprint';\nimport { withLastLoggedInUser } from './enhancers/withLastLoggedInUser';\nimport { withNotifications } from './enhancers/withNotifications';\nimport withPersistTokens from './enhancers/withPersistTokens';\nimport createSdk from './sdk';\n\nconst decoratedCreateSdk = compose(\n  withFingerprint,\n  withAutoRefresh,\n  withAnalytics,\n  withNotifications,\n  withLastLoggedInUser, // must be one before last due to TS types\n  withPersistTokens, // must be last due to TS known limitation https://github.com/microsoft/TypeScript/issues/30727\n)(createSdk);\n\nexport type { UserResponse } from './types';\n\n// Note: make sure to update packages/web-js-sdk/test/umd.test.ts when adding new constants\nexport {\n  REFRESH_TOKEN_KEY,\n  SESSION_TOKEN_KEY,\n} from './enhancers/withPersistTokens/constants';\n\nexport {\n  ensureFingerprintIds,\n  clearFingerprintData,\n} from './enhancers/withFingerprint/helpers';\n\nexport type { OneTapConfig } from './sdk/fedcm';\n\nexport default decoratedCreateSdk;\n","import { CreateWebSdk, WebSdk } from '../../sdk';\n\ntype Fn = (arg: any) => any;\n\nexport function compose<Input, A1>(\n  fn1: (input: Input) => A1\n): (input: Input) => A1;\n\nexport function compose<Input, A1, A2>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2\n): (input: Input) => A2;\n\nexport function compose<Input, A1, A2, A3>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3\n): (input: Input) => A3;\n\nexport function compose<Input, A1, A2, A3, A4>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4\n): (input: Input) => A4;\n\nexport function compose<Input, A1, A2, A3, A4, A5>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5\n): (input: Input) => A5;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6\n): (input: Input) => A6;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7\n): (input: Input) => A7;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8\n): (input: Input) => A8;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9\n): (input: Input) => A9;\n\nexport function compose<Input, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>(\n  fn1: (input: Input) => A1,\n  fn2: (input: A1) => A2,\n  fn3: (input: A2) => A3,\n  fn4: (input: A3) => A4,\n  fn5: (input: A4) => A5,\n  fn6: (input: A5) => A6,\n  fn7: (input: A6) => A7,\n  fn8: (input: A7) => A8,\n  fn9: (input: A8) => A9,\n  fn10: (input: A9) => A10\n): (input: Input) => A10;\n\n/**\n * Currently there is no way to create a compose function in Typescript without using overloading\n * This function currently support up to 10 wrappers\n * If needed you can add more by duplicating the type and add more parameters\n */\n\nexport function compose(...args: Fn[]) {\n  return (data: any) => args.reduce((acc, elem) => elem(acc), data) as any;\n}\n","import { SdkFnWrapper, wrapWith } from '@descope/core-js-sdk';\nimport { CreateWebSdk } from '../../sdk';\nimport { AfterRequestHook } from '../../types';\nimport { addHooks, getAuthInfoFromResponse } from '../helpers';\nimport {\n  createTimerFunctions,\n  getTokenExpiration,\n  millisecondsUntilDate,\n} from './helpers';\nimport { AutoRefreshOptions } from './types';\nimport logger from '../helpers/logger';\nimport { IS_BROWSER, MAX_TIMEOUT } from '../../constants';\nimport { getRefreshToken } from '../withPersistTokens/helpers';\n\n// The amount of time (ms) to trigger the refresh before session expires\nconst REFRESH_THRESHOLD = 20 * 1000; // 20 sec\n\n/**\n * Automatically refresh the session token before it expires\n * It uses the the refresh token that is extracted from API response to do that\n */\nexport const withAutoRefresh =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  ({ autoRefresh, ...config }: Parameters<T>[0] & AutoRefreshOptions) => {\n    if (!autoRefresh) return createSdk(config);\n\n    // if we hold a single timer id, there might be a case where we override it before canceling the timer, this might cause many calls to refresh\n    // in order to prevent it, we hold a list of timers and cancel all of them when a new timer is set, which means we should have one active timer only at a time\n    const { clearAllTimers, setTimer } = createTimerFunctions();\n\n    // we need to hold the expiration time and the refresh token in order to refresh the session\n    // when the user comes back to the tab or from background/lock screen/etc.\n    let sessionExpiration: Date;\n    let refreshToken: string;\n    if (IS_BROWSER) {\n      document.addEventListener('visibilitychange', () => {\n        // tab becomes visible and the session is expired, do a refresh\n        if (\n          document.visibilityState === 'visible' &&\n          new Date() > sessionExpiration\n        ) {\n          logger.debug('Expiration time passed, refreshing session');\n          // We prefer the persisted refresh token over the one from the response\n          // for a case that the token was refreshed from another tab, this mostly relevant\n          // when the project uses token rotation\n          sdk.refresh(getRefreshToken() || refreshToken);\n        }\n      });\n    }\n\n    const afterRequest: AfterRequestHook = async (_req, res) => {\n      const { refreshJwt, sessionJwt } = await getAuthInfoFromResponse(res);\n\n      // if we got 401 we want to cancel all timers\n      if (res?.status === 401) {\n        logger.debug('Received 401, canceling all timers');\n        clearAllTimers();\n      } else if (sessionJwt) {\n        sessionExpiration = getTokenExpiration(sessionJwt);\n        if (!sessionExpiration) {\n          logger.debug('Could not extract expiration time from session token');\n          return;\n        }\n        refreshToken = refreshJwt;\n        let timeout =\n          millisecondsUntilDate(sessionExpiration) - REFRESH_THRESHOLD;\n\n        if (timeout > MAX_TIMEOUT) {\n          logger.debug(\n            `Timeout is too large (${timeout}ms), setting it to ${MAX_TIMEOUT}ms`,\n          );\n          timeout = MAX_TIMEOUT;\n        }\n        clearAllTimers();\n\n        const refreshTimeStr = new Date(\n          Date.now() + timeout,\n        ).toLocaleTimeString('en-US', { hour12: false });\n        logger.debug(\n          `Setting refresh timer for ${refreshTimeStr}. (${timeout}ms)`,\n        );\n\n        setTimer(() => {\n          logger.debug('Refreshing session due to timer');\n          // We prefer the persisted refresh token over the one from the response\n          // for a case that the token was refreshed from another tab, this mostly relevant\n          // when the project uses token rotation\n          sdk.refresh(getRefreshToken() || refreshJwt);\n        }, timeout);\n      }\n    };\n\n    const sdk = createSdk(addHooks(config, { afterRequest }));\n\n    const wrapper: SdkFnWrapper<{}> =\n      (fn) =>\n      async (...args) => {\n        const resp = await fn(...args);\n        logger.debug('Clearing all timers');\n        clearAllTimers();\n\n        return resp;\n      };\n\n    return wrapWith(sdk, ['logout', 'logoutAll'], wrapper);\n  };\n","import jwtDecode, { JwtPayload } from 'jwt-decode';\n\n/**\n * Get the JWT expiration WITHOUT VALIDATING the JWT\n * @param token The JWT to extract expiration from\n * @returns The Date for when the JWT expires or null if there is an issue\n */\nexport const getTokenExpiration = (token: string) => {\n  try {\n    const claims = jwtDecode<JwtPayload>(token);\n    if (claims.exp) {\n      return new Date(claims.exp * 1000);\n    }\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const millisecondsUntilDate = (date: Date) =>\n  date ? date.getTime() - new Date().getTime() : 0;\n\nexport const createTimerFunctions = () => {\n  const timerIds: NodeJS.Timeout[] = [];\n\n  const clearAllTimers = () => {\n    while (timerIds.length) {\n      clearTimeout(timerIds.pop());\n    }\n  };\n\n  const setTimer = (cb: () => void, timeout: number) => {\n    timerIds.push(setTimeout(cb, timeout));\n  };\n\n  return { clearAllTimers, setTimer };\n};\n","import { CreateWebSdk } from '../sdk';\nimport { BeforeRequestHook } from '../types';\nimport { addHooks } from './helpers';\n\n// this is replaced in build time\ndeclare const BUILD_VERSION: string;\n/**\n * Adds analytics headers to requests\n */\nexport const withAnalytics =\n  <T extends CreateWebSdk>(createSdk: T) =>\n  (config: Parameters<T>[0]) =>\n    createSdk({\n      ...config,\n      baseHeaders: {\n        'x-descope-sdk-name': 'web-js',\n        'x-descope-sdk-version': BUILD_VERSION,\n        ...config.baseHeaders,\n      },\n    });\n"],"names":["addHooks","config","hooks","reduce","acc","key","concat","_a","getAuthInfoFromResponse","async","res","ok","body","clone","json","authInfo","getUserFromResponse","user","hasOwnProperty","undefined","isLocalStorage","localStorage","setLocalStorage","value","setItem","getLocalStorage","getItem","removeLocalStorage","removeItem","logger","args","console","debug","IS_BROWSER","window","MAX_TIMEOUT","Math","pow","SESSION_TOKEN_KEY","REFRESH_TOKEN_KEY","setJwtTokenCookie","name","cookiePath","cookieDomain","cookieExpiration","expires","Date","domainMatches","currentDomainParts","location","hostname","split","cookieDomainParts","slice","length","join","isCurrentDomainOrParentDomain","Cookies","set","path","domain","sameSite","secure","getRefreshToken","prefix","clearTokens","remove","FP_EP_URL","FP_STORAGE_KEY","getFPFromStorage","returnExpired","itemStr","item","JSON","parse","getTime","expiry","ensureFingerprintIds","fpKey","baseUrl","sessionId","now","toString","random","substring","endpointUrl","URL","pathname","patterUrl","scriptUrlPattern","agentP","load","apiKey","endpoint","defaultEndpoint","defaultScriptUrlPattern","agent","requestId","get","linkedId","fpData","vsid","vrid","createFingerprintObject","stringify","setFPToStorage","ex","warn","clearFingerprintData","beforeRequest","data","LOCAL_STORAGE_LAST_USER_LOGIN_ID","LOCAL_STORAGE_LAST_USER_DISPLAY_NAME","getLastUserLoginId","getLastUserDisplayName","startWrapper","fn","options","loginId","displayName","lastAuth","logoutWrapper","resp","createPubSub","cbs","pub","forEach","cb","sub","idx","push","splice","wrapper","create","createOptions","publicKey","challenge","decodeBase64Url","id","excludeCredentials","decodeCreateOptions","createResponse","navigator","credentials","credential","rawId","encodeBase64Url","type","response","attestationObject","clientDataJSON","getOptions","decodeGetOptions","encodeGetResponse","conditional","abort","signal","mediation","isSupported","requirePlatformAuthenticator","Promise","resolve","supported","PublicKeyCredential","isUserVerifyingPlatformAuthenticatorAvailable","allowCredentials","authenticatorData","signature","userHandle","base64","replace","Uint8Array","from","atob","c","charCodeAt","buffer","btoa","String","fromCharCode","apply","creator","createWebAuthn$1","sdk","identifier","startResponse","webauthn","signUp","start","origin","finish","transactionId","signIn","getResponse","signUpOrIn","token","update","helpers","obj","Object","assign","apiPaths","createFedCM","projectId","provider","oneTapConfig","loginOptions","onSkip","readyProvider","oauth","startNative","clientId","stateId","nonce","googleClient","reject","google","accounts","googleScript","document","getElementById","createElement","head","appendChild","defer","src","onload","onerror","getGoogleClient","initialize","itp_support","use_fedcm_for_prompt","_b","client_id","callback","finishNative","prompt","notification","isSkippedMoment","context","req","identity","providers","configURL","httpClient","buildUrl","refresh","withFlow","coreSdk","flow","webAuthnSupport","decoratedOptions","href","deviceInfo","startOptionsVersion","decoratedCreateSdk","elem","compose","createSdk","fpLoad","__rest","catch","autoRefresh","clearAllTimers","setTimer","timerIds","clearTimeout","pop","timeout","setTimeout","createTimerFunctions","sessionExpiration","refreshToken","addEventListener","visibilityState","afterRequest","_req","refreshJwt","sessionJwt","status","claims","jwtDecode","exp","e","getTokenExpiration","date","refreshTimeStr","toLocaleTimeString","hour12","wrapWith","baseHeaders","sessionPS","userPS","userDetails","wrappedSdk","onSessionTokenChange","onUserChange","storeLastAuthenticatedUser","loginIds","setLastUserLoginId","setLastUserDisplayName","persistTokens","isPersistTokens","sessionTokenViaCookie","storagePrefix","isManagementApi","test","cookieParams","getSessionToken","createCoreSdk","createWebAuthn","fedcm"],"mappings":"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"}